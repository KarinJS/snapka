import fs from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import { normalizePath } from '../utils/path-utils'

/**
 * Platform names used to identify a OS platform x architecture combination in the way
 * that is relevant for the browser download.
 *
 * @public
 */
export enum BrowserPlatform {
  LINUX = 'linux',
  LINUX_ARM = 'linux_arm',
  MAC = 'mac',
  MAC_ARM = 'mac_arm',
  WIN32 = 'win32',
  WIN64 = 'win64',
}

/**
 * Supported browsers.
 *
 * @public
 */
export enum Browser {
  CHROME = 'chrome',
  CHROMEHEADLESSSHELL = 'chrome-headless-shell',
  CHROMIUM = 'chromium',
  CHROMEDRIVER = 'chromedriver',
}

/**
 * Puppeteer 浏览器查找结果(仅包含二进制文件存在的浏览器)
 */
export interface PuppeteerBrowserResult {
  /** 浏览器类型 */
  type: Browser
  /** 浏览器版本 */
  version: string
  /** 发布通道 */
  channel: string
  /** 浏览器安装路径 */
  dir: string
  /** 可执行文件路径 */
  executablePath: string
}

/**
 * Puppeteer 浏览器目录信息(包含所有目录，不管二进制是否存在)
 */
export interface PuppeteerBrowserDirectory {
  /** 浏览器类型 */
  type: Browser
  /** 浏览器版本 */
  version: string
  /** 发布通道 */
  channel: string
  /** 浏览器安装路径 */
  dir: string
  /** 可执行文件路径，如果不存在则为 undefined */
  executablePath: string | undefined
}

/**
 * Puppeteer 浏览器查找器
 * 所有的目录构成的都遵循 Puppeteer 的缓存结构
 */
export class PuppeteerBrowserFinder {
  /** 浏览器缓存目录 */
  private browserCacheDir: string
  /** 当前平台 */
  private platform: BrowserPlatform

  constructor () {
    // 获取当前平台
    this.platform = this.getCurrentPlatform()

    // 获取缓存目录
    if (process.env.PUPPETEER_CACHE_DIR) {
      this.browserCacheDir = process.env.PUPPETEER_CACHE_DIR
    } else if (process.env.PUPPETEER_SKIP_CHROMIUM_DOWNLOAD !== 'true' && process.env.PUPPETEER_EXECUTABLE_PATH) {
      const execPath = process.env.PUPPETEER_EXECUTABLE_PATH
      const parts = execPath.split(path.sep)
      const puppeteerIndex = parts.indexOf('puppeteer')
      if (puppeteerIndex !== -1) {
        this.browserCacheDir = parts.slice(0, puppeteerIndex + 1).join(path.sep)
      } else {
        this.browserCacheDir = this.getDefaultCacheDir()
      }
    } else {
      this.browserCacheDir = this.getDefaultCacheDir()
    }
  }

  /**
   * 获取当前平台
   */
  private getCurrentPlatform (): BrowserPlatform {
    const platform = os.platform()
    const arch = os.arch()

    if (platform === 'linux') {
      return arch === 'arm64' || arch === 'arm' ? BrowserPlatform.LINUX_ARM : BrowserPlatform.LINUX
    }
    if (platform === 'darwin') {
      return arch === 'arm64' ? BrowserPlatform.MAC_ARM : BrowserPlatform.MAC
    }
    if (platform === 'win32') {
      return arch === 'x64' ? BrowserPlatform.WIN64 : BrowserPlatform.WIN32
    }

    throw new Error(`Unsupported platform: ${platform}`)
  }

  /**
   * 获取默认缓存目录
   */
  private getDefaultCacheDir (): string {
    const homeDir = os.homedir()
    const platform = os.platform()

    if (platform === 'win32') {
      return path.join(homeDir, '.cache', 'puppeteer')
    } else if (platform === 'darwin') {
      const xdgCache = process.env.XDG_CACHE_HOME
      if (xdgCache) {
        return path.join(xdgCache, 'puppeteer')
      }
      return path.join(homeDir, '.cache', 'puppeteer')
    } else {
      const xdgCache = process.env.XDG_CACHE_HOME
      if (xdgCache) {
        return path.join(xdgCache, 'puppeteer')
      }
      return path.join(homeDir, '.cache', 'puppeteer')
    }
  }

  /**
   * 比较版本号，用于排序(新版本在前)
   */
  private compareVersions (a: string, b: string): number {
    if (a === 'system' && b === 'system') return 0
    if (a === 'system') return 1
    if (b === 'system') return -1

    const parseVersion = (version: string) => {
      const cleaned = version.replace(/[^\d.]/g, '')
      const parts = cleaned.split('.').map(Number)
      while (parts.length < 4) parts.push(0)
      return parts
    }

    const versionA = parseVersion(a)
    const versionB = parseVersion(b)

    for (let i = 0; i < Math.max(versionA.length, versionB.length); i++) {
      const partA = versionA[i] || 0
      const partB = versionB[i] || 0

      if (partA > partB) return -1
      if (partA < partB) return 1
    }

    return 0
  }

  /**
   * 根据版本号判断Chrome的发布通道
   */
  private detectChromeChannel (version: string): string {
    if (version.includes('canary') || version.includes('dev')) {
      return 'canary'
    }
    if (version.includes('beta')) {
      return 'beta'
    }
    return 'stable'
  }

  /**
   * 获取平台文件夹名称
   */
  private getChromeFolder (platform: BrowserPlatform): string {
    switch (platform) {
      case BrowserPlatform.LINUX_ARM:
        return 'linux_arm'
      case BrowserPlatform.LINUX:
        return 'linux'
      case BrowserPlatform.MAC_ARM:
        return 'mac_arm'
      case BrowserPlatform.MAC:
        return 'mac'
      case BrowserPlatform.WIN32:
        return 'win32'
      case BrowserPlatform.WIN64:
        return 'win64'
    }
  }

  /**
   * 获取Chrome可执行文件路径
   */
  private getChromeExecutablePath (platform: BrowserPlatform, browserType: Browser, version: string): string {
    switch (platform) {
      case BrowserPlatform.MAC:
      case BrowserPlatform.MAC_ARM:
        if (browserType === Browser.CHROME) {
          const folderSuffix = platform === BrowserPlatform.MAC_ARM ? 'mac-arm64' : 'mac-x64'
          return path.join(
            `chrome-${folderSuffix}`,
            'Google Chrome for Testing.app',
            'Contents',
            'MacOS',
            'Google Chrome for Testing'
          )
        } else if (browserType === Browser.CHROMEHEADLESSSHELL) {
          const folderSuffix = platform === BrowserPlatform.MAC_ARM ? 'mac-arm64' : 'mac-x64'
          return path.join(
            `chrome-headless-shell-${folderSuffix}`,
            'chrome-headless-shell'
          )
        } else if (browserType === Browser.CHROMEDRIVER) {
          const folderSuffix = platform === BrowserPlatform.MAC_ARM ? 'mac-arm64' : 'mac-x64'
          return path.join(`chromedriver-${folderSuffix}`, 'chromedriver')
        }
        break
      case BrowserPlatform.LINUX_ARM:
      case BrowserPlatform.LINUX:
        if (browserType === Browser.CHROME) {
          return path.join('chrome-linux64', 'chrome')
        } else if (browserType === Browser.CHROMEHEADLESSSHELL) {
          return path.join('chrome-headless-shell-linux64', 'chrome-headless-shell')
        } else if (browserType === Browser.CHROMEDRIVER) {
          return path.join('chromedriver-linux64', 'chromedriver')
        }
        break
      case BrowserPlatform.WIN32:
      case BrowserPlatform.WIN64:
        if (browserType === Browser.CHROME) {
          const folderSuffix = platform === BrowserPlatform.WIN64 ? 'win64' : 'win32'
          return path.join(`chrome-${folderSuffix}`, 'chrome.exe')
        } else if (browserType === Browser.CHROMEHEADLESSSHELL) {
          const folderSuffix = platform === BrowserPlatform.WIN64 ? 'win64' : 'win32'
          return path.join(`chrome-headless-shell-${folderSuffix}`, 'chrome-headless-shell.exe')
        } else if (browserType === Browser.CHROMEDRIVER) {
          const folderSuffix = platform === BrowserPlatform.WIN64 ? 'win64' : 'win32'
          return path.join(`chromedriver-${folderSuffix}`, 'chromedriver.exe')
        }
        break
    }

    throw new Error(`Unsupported browser type ${browserType} on platform ${platform}`)
  }

  /**
   * 获取Chromium可执行文件路径
   */
  private getChromiumExecutablePath (platform: BrowserPlatform): string {
    switch (platform) {
      case BrowserPlatform.MAC:
      case BrowserPlatform.MAC_ARM:
        return path.join(
          'chrome-mac',
          'Chromium.app',
          'Contents',
          'MacOS',
          'Chromium'
        )
      case BrowserPlatform.LINUX_ARM:
      case BrowserPlatform.LINUX:
        return path.join('chrome-linux', 'chrome')
      case BrowserPlatform.WIN32:
      case BrowserPlatform.WIN64:
        return path.join('chrome-win', 'chrome.exe')
    }
  }

  /**
   * 获取Chromium平台文件夹名称
   */
  private getChromiumPlatformFolder (platform: BrowserPlatform): string {
    switch (platform) {
      case BrowserPlatform.LINUX_ARM:
      case BrowserPlatform.LINUX:
        return 'Linux_x64'
      case BrowserPlatform.MAC_ARM:
        return 'Mac_Arm'
      case BrowserPlatform.MAC:
        return 'Mac'
      case BrowserPlatform.WIN32:
        return 'Win'
      case BrowserPlatform.WIN64:
        return 'Win_x64'
      default:
        throw new Error(`Unsupported platform: ${platform}`)
    }
  }

  /**
   * 收集Chrome系列浏览器(单个浏览器类型)
   * @param browsers 浏览器结果数组
   * @param browserType 浏览器类型
   * @param stopOnFirst 是否找到第一个就停止
   * @returns 如果找到并停止，返回 true
   */
  private collectChromeBrowser (browsers: PuppeteerBrowserDirectory[], browserType: Browser, stopOnFirst: boolean = false): boolean {
    const browserDir = path.join(this.browserCacheDir, browserType)

    if (!fs.existsSync(browserDir)) {
      return false
    }

    try {
      const entries = fs.readdirSync(browserDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)

      const platformFolder = this.getChromeFolder(this.platform)
      const versionDirs = entries.filter(dir => dir.startsWith(`${platformFolder}-`))

      // 如果需要找到第一个就停止，我们应该按版本倒序排序(新版本优先)
      // 这里的 versionDirs 格式是 platform-version，我们需要提取 version 进行比较
      if (stopOnFirst) {
        versionDirs.sort((a, b) => {
          const verA = a.replace(`${platformFolder}-`, '')
          const verB = b.replace(`${platformFolder}-`, '')
          return this.compareVersions(verA, verB)
        })
      }

      for (const versionDir of versionDirs) {
        const version = versionDir.replace(`${platformFolder}-`, '')
        const fullVersionDir = path.join(browserDir, versionDir)
        const relativePath = this.getChromeExecutablePath(this.platform, browserType, version)
        const executablePath = path.join(fullVersionDir, relativePath)
        const exists = fs.existsSync(executablePath)

        browsers.push({
          type: browserType,
          version,
          channel: this.detectChromeChannel(version),
          dir: normalizePath(fullVersionDir),
          executablePath: exists ? normalizePath(executablePath) : undefined,
        })

        if (stopOnFirst && exists) {
          return true
        }
      }
    } catch (error) {
      console.warn(`Error scanning ${browserType}:`, error)
    }
    return false
  }

  /**
   * 收集Chromium浏览器
   * @param browsers 浏览器结果数组
   * @param stopOnFirst 是否找到第一个就停止
   * @returns 如果找到并停止，返回 true
   */
  private collectChromiumBrowser (browsers: PuppeteerBrowserDirectory[], stopOnFirst: boolean = false): boolean {
    const browserDir = path.join(this.browserCacheDir, Browser.CHROMIUM)

    if (!fs.existsSync(browserDir)) {
      return false
    }

    try {
      const platformFolder = this.getChromiumPlatformFolder(this.platform)
      const platformDir = path.join(browserDir, platformFolder)

      if (!fs.existsSync(platformDir)) {
        return false
      }

      const buildIds = fs.readdirSync(platformDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name)
        .filter(name => /^\d+$/.test(name))

      // 如果需要找到第一个就停止，我们应该按版本倒序排序(新版本优先)
      if (stopOnFirst) {
        buildIds.sort((a, b) => this.compareVersions(a, b))
      }

      for (const buildId of buildIds) {
        const buildDir = path.join(platformDir, buildId)
        const relativePath = this.getChromiumExecutablePath(this.platform)
        const executablePath = path.join(buildDir, relativePath)
        const exists = fs.existsSync(executablePath)

        browsers.push({
          type: Browser.CHROMIUM,
          version: buildId,
          channel: 'nightly',
          dir: normalizePath(buildDir),
          executablePath: exists ? normalizePath(executablePath) : undefined,
        })

        if (stopOnFirst && exists) {
          return true
        }
      }
    } catch (error) {
      console.warn('Error scanning Chromium:', error)
    }
    return false
  }

  /**
   * 查找所有已安装的浏览器(仅返回二进制文件存在的)
   */
  async find (): Promise<PuppeteerBrowserResult[]> {
    const all = await this.findAllDirectories()
    return all.filter(val => val.executablePath !== undefined) as PuppeteerBrowserResult[]
  }

  /**
   * 查找所有已安装的浏览器(同步，仅返回二进制文件存在的)
   */
  findSync (): PuppeteerBrowserResult[] {
    const all = this.findAllDirectoriesSync()
    return all.filter(val => val.executablePath !== undefined) as PuppeteerBrowserResult[]
  }

  /**
   * 查找所有浏览器目录(包含二进制不存在的)
   */
  async findAllDirectories (): Promise<PuppeteerBrowserDirectory[]> {
    // 异步方法目前复用同步逻辑，因为fs操作主要是同步的
    return this.findAllDirectoriesSync()
  }

  /**
   * 查找所有浏览器目录(同步，包含二进制不存在的)
   */
  findAllDirectoriesSync (): PuppeteerBrowserDirectory[] {
    if (!fs.existsSync(this.browserCacheDir)) return []

    const browsers: PuppeteerBrowserDirectory[] = []

    // 扫描Chrome系列浏览器
    this.collectChromeBrowser(browsers, Browser.CHROME)
    this.collectChromeBrowser(browsers, Browser.CHROMEHEADLESSSHELL)
    this.collectChromeBrowser(browsers, Browser.CHROMEDRIVER)

    // 扫描Chromium浏览器
    this.collectChromiumBrowser(browsers)

    // 对结果按版本号排序(新版本在前)，相同版本时按类型排序
    browsers.sort((a, b) => {
      const versionCompare = this.compareVersions(a.version, b.version)
      if (versionCompare !== 0) {
        return versionCompare
      }
      return a.type.localeCompare(b.type)
    })

    return browsers
  }

  /**
   * 内部查找第一个匹配的浏览器
   */
  private findFirstInternal (targetType?: Browser): PuppeteerBrowserResult | undefined {
    if (!fs.existsSync(this.browserCacheDir)) return undefined

    const browsers: PuppeteerBrowserDirectory[] = []

    if (targetType) {
      if (targetType === Browser.CHROMIUM) {
        if (this.collectChromiumBrowser(browsers, true)) {
          return browsers[browsers.length - 1] as PuppeteerBrowserResult
        }
      } else {
        if (this.collectChromeBrowser(browsers, targetType, true)) {
          return browsers[browsers.length - 1] as PuppeteerBrowserResult
        }
      }
    } else {
      // 查找任意一个，按优先级顺序：Chrome > Chromium > ChromeHeadlessShell
      if (this.collectChromeBrowser(browsers, Browser.CHROME, true)) {
        return browsers[browsers.length - 1] as PuppeteerBrowserResult
      }
      if (this.collectChromiumBrowser(browsers, true)) {
        return browsers[browsers.length - 1] as PuppeteerBrowserResult
      }
      if (this.collectChromeBrowser(browsers, Browser.CHROMEHEADLESSSHELL, true)) {
        return browsers[browsers.length - 1] as PuppeteerBrowserResult
      }
      // ChromeDriver 通常不作为浏览器返回，除非明确指定
    }

    return undefined
  }

  /**
   * 查找Chrome浏览器
   */
  async findChrome () {
    const browsers = await this.find()
    return browsers.find(b => b.type === Browser.CHROME)
  }

  /**
   * 查找Chrome Headless Shell浏览器
   */
  async findChromeHeadlessShell () {
    const browsers = await this.find()
    return browsers.find(b => b.type === Browser.CHROMEHEADLESSSHELL)
  }

  /**
   * 查找ChromeDriver
   */
  async findChromeDriver () {
    const browsers = await this.find()
    return browsers.find(b => b.type === Browser.CHROMEDRIVER)
  }

  /**
   * 查找Chromium浏览器
   */
  async findChromium () {
    const browsers = await this.find()
    return browsers.find(b => b.type === Browser.CHROMIUM)
  }

  /**
   * 查找Chrome浏览器(同步方法)
   */
  findChromeSync () {
    const browsers = this.findSync()
    return browsers.find(b => b.type === Browser.CHROME)
  }

  /**
   * 查找Chrome Headless Shell浏览器(同步方法)
   */
  findChromeHeadlessShellSync () {
    const browsers = this.findSync()
    return browsers.find(b => b.type === Browser.CHROMEHEADLESSSHELL)
  }

  /**
   * 查找ChromeDriver(同步方法)
   */
  findChromeDriverSync () {
    const browsers = this.findSync()
    return browsers.find(b => b.type === Browser.CHROMEDRIVER)
  }

  /**
   * 查找Chromium浏览器(同步方法)
   */
  findChromiumSync () {
    const browsers = this.findSync()
    return browsers.find(b => b.type === Browser.CHROMIUM)
  }

  /**
   * 查找任意一个可用的浏览器(找到即返回，异步优化版本)
   */
  async findFirstAny (): Promise<PuppeteerBrowserResult | undefined> {
    return this.findFirstInternal()
  }

  /**
   * 查找第一个Chrome浏览器(找到即返回，异步优化版本)
   */
  async findFirstChrome (): Promise<PuppeteerBrowserResult | undefined> {
    return this.findFirstInternal(Browser.CHROME)
  }

  /**
   * 查找第一个Chrome Headless Shell浏览器(找到即返回，异步优化版本)
   */
  async findFirstChromeHeadlessShell (): Promise<PuppeteerBrowserResult | undefined> {
    return this.findFirstInternal(Browser.CHROMEHEADLESSSHELL)
  }

  /**
   * 查找第一个ChromeDriver(找到即返回，异步优化版本)
   */
  async findFirstChromeDriver (): Promise<PuppeteerBrowserResult | undefined> {
    return this.findFirstInternal(Browser.CHROMEDRIVER)
  }

  /**
   * 查找第一个Chromium浏览器(找到即返回，异步优化版本)
   */
  async findFirstChromium (): Promise<PuppeteerBrowserResult | undefined> {
    return this.findFirstInternal(Browser.CHROMIUM)
  }

  /**
   * 查找任意一个可用的浏览器(找到即返回，同步优化版本)
   */
  findFirstAnySync (): PuppeteerBrowserResult | undefined {
    return this.findFirstInternal()
  }

  /**
   * 查找第一个Chrome浏览器(找到即返回，同步优化版本)
   */
  findFirstChromeSync (): PuppeteerBrowserResult | undefined {
    return this.findFirstInternal(Browser.CHROME)
  }

  /**
   * 查找第一个Chrome Headless Shell浏览器(找到即返回，同步优化版本)
   */
  findFirstChromeHeadlessShellSync (): PuppeteerBrowserResult | undefined {
    return this.findFirstInternal(Browser.CHROMEHEADLESSSHELL)
  }

  /**
 * 查找第一个ChromeDriver(找到即返回，同步优化版本)
 */
  findFirstChromeDriverSync (): PuppeteerBrowserResult | undefined {
    return this.findFirstInternal(Browser.CHROMEDRIVER)
  }

  /**
 * 查找第一个Chromium浏览器(找到即返回，同步优化版本)
 */
  findFirstChromiumSync (): PuppeteerBrowserResult | undefined {
    return this.findFirstInternal(Browser.CHROMIUM)
  }
}

/**
 * Puppeteer 浏览器查找器
 */
export const puppeteerBrowserFinder = new PuppeteerBrowserFinder()
